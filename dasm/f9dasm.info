FILE ../images/27256.bin 0x8000
OPTION noflex
DATA 0x8000-0x8002
CODE 0x8003-0x81A5
DATA 0x81A6-0x81A8
CODE 0x81A9-0x821F
DATA 0x8220-0x828B
CODE 0x828C-0x832F
DATA 0x8330-0x8397
CODE 0x8398-0x83AE
DATA 0x83AF-0x83DD
CODE 0x83DE-0x83EA
CODE 0x83EB-0x8429
CODE 0x842A-0x8481
DATA 0x8482-0x84B3
CODE 0x84B4-0x8536
DATA 0x8537-0x8560
CODE 0x8561-0x8564
DATA 0x8565-0x8570
CODE 0x8571-0x858B
DATA 0x858C-0x85C2
CODE 0x85C3-0x85D4
DATA 0x85D5-0x85E2
CODE 0x85E3-0x8740
DATA 0x8741-0x8759
CODE 0x875A-0x875F
DATA 0x8760-0x8E8E
CODE 0x8E8F-0x8EF0
DATA 0x8EF1-0x8EF3
CODE 0x8EF4-0x8F29
DATA 0x8F2A-0x900C
CODE 0x900D-0x90D3
DATA 0x90D4-0x9B77
CODE 0x9B78-0x9B8B
DATA 0x9B8C-0x9CE2
CODE 0x9CE3-0x9D65
DATA 0x9D66-0xB0C5
CODE 0xB0C6-0xB11C
DATA 0xB11D-0xB204
CODE 0xB205-0xB549
DATA 0xB54A-0xB54B
CODE 0xB54C-0xB6D7
DATA 0xB6D8-0xB6EF
CODE 0xB6F0-0xB966
DATA 0xB967-0xBAD9
CODE 0xBADA-0xBAF1
DATA 0xBAF2-0xBAFF
CODE 0xBB00-0xBB07
DATA 0xBB08-0xBB2D
CODE 0xBB2E-0xBB7F
DATA 0xBB80-0xBD5B
CODE 0xBD5C-0xBD6D
DATA 0xBD6E-0xC043
CODE 0xC044-0xC07C
DATA 0xC07D-0xC086
CODE 0xC087-0xC131
CVEC 0xC132-0xC1C0
CODE 0xC1C1-0xC1CE
DATA 0xC1CF-0xC1CF
CODE 0cC1D0-0xC1F0
DATA 0xC1F1-0xC1F4
CODE 0xC1F5-0xC223
DATA 0xC224-0xC224
CODE 0xC225-0xC26A
DATA 0xC26B-0xC26D
CODE 0xC26E-0xC29E
DATA 0xC29F-0xC29F
CODE 0xC2A0-0xC330
DATA 0xC331-0xC339
CODE 0xC33A-0xC37F
DATA 0xC380-0xC382
CODE 0xC383-0xC3B2
DATA 0xC3B3-0xC3B3
CODE 0xC3B4-0xC3E3
DATA 0xC3E4-0xC3E4
CODE 0xC3E5-0xC427
DATA 0xC428-0xC42A
CODE 0xC42B-0xC434
DATA 0xC435-0xC456
CODE 0xC457-0xC480
DATA 0xC481-0xC493
CODE 0xC494-0xC4AB
CVEC 0xC4AC-0xC4BB
CODE 0xC4BC-0xC657
DATA 0xC658-0xC65D
CODE 0xC65E-0xC835
CODE 0xC836-0xC83F
CVEC 0xC840-0xC85F
CODE 0xC860-0xC9E5
CVEC 0xC9E6-0xCA03
CODE 0xCA04-0xCB56
CVEC 0xCB57-0xCB60
CODE 0xCB61-0xCD0D
DATA 0xCD0E-0xCD1F
CODE 0xCD20-0xD06D
CODE 0xD06E-0xD15D
DATA 0xD15E-0xD1A7
BIN 0xD15E-0xD1A7

CODE 0xD1A8-0xD1FD
DATA 0xD1FE-0xD245
CODE 0xD246-0xD27A
DATA 0xD27B-0xD294
CODE 0xD295-0xD2AA
DATA 0xD2AB-0xD2B4
CODE 0xD2B5-0xD3DD
DATA 0xD3DE-0xD5FA
CODE 0xD3FB-0xD682
DATA 0xD683-0xDB94
CODE 0xDB95-0xDC3F
DATA 0xDC40-0xDC40
CODE 0xDC41-0xDDF7
DATA 0xDDF8-0xFFEF


LABEL 0x1000 DACBASE
LABEL 0x1400 UARTBASE
LABEL 0x1406 UARTCSR
LABEL 0x1407 UARTDATA
LABEL 0x1600 PITBASE
LABEL 0x1800 PUSHBTN07
LABEL 0x1801 PUSHBTNMISC
LABEL 0x1D00 MISCBITS
LABEL 0x1D80 BANKSELECT
LABEL 0x1E00 LED7SEG1
LABEL 0x1E80 LED7SEG2
LABEL 0x1F00 LED7SEG3
LABEL 0x1F80 LEDSINGLES
LABEL 0x2000 PATCHROMSTART
LABEL 0x4000 EPROMSTART
LABEL 0x6000 RAMSTART 
LABEL 0x7222 LOOPCOUNTER
LABEL 0x7593 UARTRXD_START
LABEL 0x7792 UARTRXD_END
LABEL 0x7793 UARTTXD_START
LABEL 0x7992 UARTTXD_END
LABEL 0x7993 UARTRXD_RPTR * not definite but looks likely by initialisation
LABEL 0x7995 UARTRXD_WPTR
LABEL 0x7997 UARTTXD_RPTR
LABEL 0x7999 UARTTXD_WPTR * not definite but looks likely by initialisation 
LABEL 0x79C1 LED_CHAR_BUFFER
LABEL 0x79F9 IRQHANDLERADDR
LABEL 0x7A0D LEDSINGLES_SHADOW
LABEL 0x7C4D BANKSELECT_SHADOW
LABEL 0x7FFF STACKSTART
RMB 0xE1E7-0xFFF1
CVEC 0xFFF0-0xFFFF

LABEL    0x8000 VERSION
LABEL    0x800C WARM_RESTART
LCOMMENT 0x800C disable interrupts
LCOMMENT 0x800E initialize stack location
COMMENT  0x8014 Next two writes appear to write to bit 7 of U703 and U704 respectively, which are n/c on p3 of original schematic?
COMMENT  0x801a assert SYNC1,MUTE, SYNC2 and WAVE

LCOMMENT 0x8026 Y => version string
LCOMMENT 0x802A B = char count
LCOMMENT 0x802C X = char buffer starting offset
CONST    0x802D-0x802E
LCOMMENT 0x802F Load up the LED character buffer
LCOMMENT 0x8032 Reset the char buffer starting offset
CONST    0x8033-0x8034
COMMENT  0x803B Delay by looping 15000 times
LCOMMENT 0x803B X = 15000 dec.
CONST    0x803C-0x803D
LABEL    0x803E DELAYLOOP_803E

COMMENT  0x8045 Initialize the bank select logic and a shadow variable for it to zero.

COMMENT  0x806B Initialize the interrupt handler trampoline

COMMENT  0x8178 Detect some button pushes
COMMENT  0x8178 If Enter is pressed on power up, reinitialize the synth (see owner's manual)
LCOMMENT 0x817B Is Enter pressed?
BIN      0x817C
LCOMMENT 0x817D No, jump
LCOMMENT 0x817F Enter pressed
LCOMMENT 0x8187 Restart
COMMENT  0x818A Pressing 2,5,9 together on powerup is an Easter Egg, displaying
COMMENT  0x818A "JSL", initials of one of the devs.
COMMENT  0x818A Ref: http://wolzow.mindworks.ee/analog/m1k-firmware.htm
LABEL    0x818A TEST_BTN9
LCOMMENT 0x818A is '9' pressed?
BIN      0x818B
LCOMMENT 0x818C No, jump
LABEL    0x818E TEST_BTN25
LCOMMENT 0x81A4 Display while buttons remain pressed
LCOMMENT 0x8191 is '5' and '2' also pressed?
BIN      0x8192
LCOMMENT 0x8193 No, jump
LCOMMENT 0x8195 Yes, display the Easter egg

LABEL    0x81A6 STR_JSL
LCOMMENT 0x81A6 Initials of James S. Letts
LABEL    0x81A9 NORMAL_STARTUP
COMMENT  0x81A9 No special buttons pressed, normal startup continues

LCOMMENT 0x81DF Enable interrupts (I think- obliterates other flags too)
BIN      0x81E0

LABEL    0x81E4 ZEROALLVCA1
COMMENT  0x81E4 Subroutine: ZEROALLVCA1 - Drive 0 to the VCA1 input of all voices
LCOMMENT 0x81E4 Iterate 50 times
DEC 0x81E5
LABEL    0x81EF LOOP_81EF
LCOMMENT 0x8200 decrement loop counter...
LCOMMENT 0x8203 ...and loop again

COMMENT 0x83EB Subroutine: 2000-iteration delay
LABEL    0x83EB DELAY_2000ITER
LCOMMENT 0x83EB save D
LCOMMENT 0x83ED D = 2000 dec
CONST    0x83EE-0x83EF
CONST    0x83F1-0x83F2
LABEL    0x83F0 LOOP_83F0
LCOMMENT 0x83F7 restore D...
LCOMMENT 0x83F9 ...and return

COMMENT  0x84B4 UART interrupt handler
LCOMMENT 0x84B4 Save X,A register values
LCOMMENT 0x84B6 Get the UART status into A
LCOMMENT 0x84B9 Is there RX data?
LCOMMENT 0x84BB If RX bit not set, jump
COMMENT  0x84BD Handle a received MIDI byte 
LCOMMENT 0x84BD A = received byte
LCOMMENT 0x84C0 get the write pointer...
LCOMMENT 0x84C3 ...and store the RX byte in the buffer
LCOMMENT 0x84C5 is the write ptr at end of buffer?
LCOMMENT 0x84C8 no, skip the ptr reset
LCOMMENT 0x84CA yes, set write ptr back to beginning of buffer
LCOMMENT 0x84D2 store the write ptr
LCOMMENT 0x84D5 has it caught up with the read ptr?

COMMENT  0x84D8 This conditional branch seems to do the same thing either way

LCOMMENT 0x84DA Restore X,A register values
LCOMMENT 0x84DC ... and return from interrupt

LCOMMENT 0x84DD Restore X,A register values
LCOMMENT 0x84DF ... and return from interrupt

LABEL    0x84E0 UART_TXINT

LCOMMENT 0x84F8 /16, 8N1, RX interrupts only
BIN      0x84F9
LCOMMENT 0x8502 Restore X,A register values
LCOMMENT 0x8504 ... and return from interrupt

LABEL    0x8505 INIT_UART
LCOMMENT 0x8505 UART master reset
BIN      0x8506
LCOMMENT 0x850A /16, 8N1, RX interrupts only
BIN      0x850B

COMMENT  0x8519 initialise the MIDI receive queue read and write pointers to the bottom of the buffer

COMMENT  0x85C3 On entry, X = new UART TXD write ptr?
LCOMMENT 0x85C3 inhibit UART interrupts
LCOMMENT 0x85C5 is X == current read ptr?
LCOMMENT 0x85C8 yes, abort
LCOMMENT 0x85CA save the write pointer
LCOMMENT 0x85CD /16, 8NQ, RX /and/ TX interrupts
BIN      0x85CE
LCOMMENT 0x85CF write the UART status
LCOMMENT 0x85D2 enable UART interrupts


LABEL    0x85E7 HANDLEIRQ


CONST    0xB271-0xB272 * incorrectly interpreted as address

COMMENT  0xC06A This is part of the Data Dump code (p32 of User Manual)
COMMENT  0xC06A In the section below, A is used as an index into the table of
COMMENT  0xC06A 4 strings below starting at STR_DB
LCOMMENT 0xC071 Multiply index by 2 to account for string length
LCOMMENT 0xC076 skip the first character in the print buffer - contains key press

LABEL    0xC07D STR_DB
LABEL    0xC07F STR_DO
LABEL    0xC081 STR_DA
LABEL    0xC083 STR_DR
LABEL    0xC085 STR_GO

LABEL    0xC1CF STR_U

LABEL    0xC1F1 STR_OF
LABEL    0xC1F3 STR_ON

LABEL    0xC224 STR_E

LABEL    0xC26B STR_TRN

LABEL    0xC331 STR_TST
LABEL    0xC334 STR_GO
LABEL    0xC337 STR_CAL

LABEL    0xC380 STR_PED

LABEL    0xC3B3 STR_I
LABEL    0xC3E4 STR_P

LABEL    0xC428 STR_BND

LABEL    0xC457 GETMIDIRX
LCOMMENT 0xC457 Get the RX buffer read pointer
LCOMMENT 0xC45A Is it the same as the write pointer?
LCOMMENT 0xC45D yes, nothing to handle, jump

COMMENT  0xD088 GDE: I think this is the subroutine that displays/refreshes the LED
LCOMMENT 0xD088 Get the current state of the individual decimal point LEDs
LCOMMENT 0xD08B LED logic is active low so invert the value
LCOMMENT 0xD08C write the value to the hardware

COMMENT  0xD136 Subroutine: DISPLAY_LED_CHAR
COMMENT  0xD136 On entry, A = ASCII code of character to be displayed
COMMENT  0xD136 B is non-zero when the decimal point is to be set as well
LABEL    0xD136 DISPLAY_LED_CHAR
LCOMMENT 0xD136 Strip the top bit of the character
LCOMMENT 0xD13B Is it a space?
LCOMMENT 0xD13D yes, jump
LCOMMENT 0xD13F is it a '-'?
LCOMMENT 0xD141 yes, jump
LCOMMENT 0xD143 0x30 = '0'; anything lower is a symbol, higher is alphanumeric
LCOMMENT 0xD147 Use a different look up table
LCOMMENT 0xD14A and offset from '0'
LABEL    0xD14C LOOKUP_LED_CHAR

COMMENT  0xD150 Character to be displayed is a '-'
LABEL    0xD150 DISPLAY_HYPHEN
COMMENT  0xD154 Character to be displayed is a space
LABEL    0xD154 DISPLAY_SPACE

COMMENT  0xD155 At this point, A contains the LED segment data for the character to be written
COMMENT  0xD155 and B is non-zero if the decimal point is to be set as wel
LABEL    0xD155 WRITE_RAW_CHAR
LCOMMENT 0xD155 If B non-zero, LED DP needs to be set
LCOMMENT 0xD158 Set the decimal point
BIN      0xD159
LABEL    0xD15A INVERT_RAW_CHAR
LCOMMENT 0xD15A Invert for active low logic
LCOMMENT 0xD15B Write to the hardware pointed to by U
LCOMMENT 0xD15D ...and we're done

LABEL    0xD15E LED_RAW_NUMERIC
LCOMMENT 0xD15E '0'
LCOMMENT 0xD15F '1'
LCOMMENT 0xD160 '2'
LCOMMENT 0xD161 '3'
LCOMMENT 0xD162 '4'
LCOMMENT 0xD163 '5'
LCOMMENT 0xD164 '6'
LCOMMENT 0xD165 '7'
LCOMMENT 0xD166 '8'
LCOMMENT 0xD167 '9'
LCOMMENT 0xD168 not used

LABEL    0xD16F LED_RAW_ALPHA
LCOMMENT 0xD16F ' '
LCOMMENT 0xD170 'A'
LCOMMENT 0xD171 'b'
LCOMMENT 0xD172 'C'
LCOMMENT 0xD173 'd'
LCOMMENT 0xD174 'E'
LCOMMENT 0xD175 'F'
LCOMMENT 0xD176 'G'
LCOMMENT 0xD177 'H'
LCOMMENT 0xD178 'I'
LCOMMENT 0xD179 'J'
LCOMMENT 0xD17A 'K'
LCOMMENT 0xD17B 'L'
LCOMMENT 0xD17C 'M'
LCOMMENT 0xD17D 'N'
LCOMMENT 0xD17E 'O'
LCOMMENT 0xD17F 'P'
LCOMMENT 0xD180 'Q'
LCOMMENT 0xD181 'r'
LCOMMENT 0xD182 'S'
LCOMMENT 0xD183 'T'
LCOMMENT 0xD184 'u'
LCOMMENT 0xD185 'v'
LCOMMENT 0xD186 'w'
LCOMMENT 0xD187 'x'
LCOMMENT 0xD188 'y'
LCOMMENT 0xD189 'z'
LCOMMENT 0xD18A Here down are some symbolic non-ASCII codings

COMMENT  0xD26A Something to do with 7-seg display.
COMMENT  0xD26A Strips bit 6 from each character in a string
COMMENT  0xD26A On entry: Y => char string
COMMENT  0xD26A           B => char count
COMMENT  0xD26A           X => ???
LABEL    0xD26A LOAD_LED_CHAR_BUFFER
LCOMMENT 0xD26A Set X to point to start of output buffer
LABEL    0xD26E LOOP_NEXT_CHAR_D26E
LCOMMENT 0xD26E Get the next character
LCOMMENT 0xD270 Zap bit 6 (?)
BIN      0xD271
LCOMMENT 0xD272 Store character in buffer
LCOMMENT 0xD274 Decrement character count
LCOMMENT 0xD275 If more characters, do next one

LABEL    0xD295 SET_CHAR_BIT_6
COMMENT  0xD295 Set bit 6 on a single character in the LED char buffer.
COMMENT  0xD295 Not entirely sure why.
COMMENT  0xD295 On entry, X = offset in char buffer to set bit 6 on
LCOMMENT 0xD295 X => indexed address in char buffer
LCOMMENT 0xD299 A = indexed character
LCOMMENT 0xD29B Set bit 6
BIN      0xD29C
LCOMMENT 0xD29D Store the char back in place

LABEL    0xD2A0 CLR_CHAR_BIT_6
COMMENT  0xD2A0 Clear bit 6 on a single character in the LED char buffer.
COMMENT  0xD2A0 Not entirely sure why.
COMMENT  0xD2A0 On entry, X = offset in char buffer to clear bit 6 on
LCOMMENT 0xD2A0 X => indexed address in char buffer
LCOMMENT 0xD2A4 A = indexed character
LCOMMENT 0xD2A6 Cleat bit 6
BIN      0xD2A7
LCOMMENT 0xD2A8 Store the char back in place


CONST    0xD630-0xD631
END